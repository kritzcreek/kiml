module List

import Option

type List<a> {
    Cons(a, List<a>),
    Nil()
}

let head : forall a. List<a> -> Option::Option<a> = \xs. match xs {
  List::Nil() -> Option::Option::None(),
  List::Cons(h, t) -> Option::Option::Some(h),
};

let unsafeHead : forall a. List<a> -> a = \xs. Option::fromSome (head xs);

let map : forall a b. (a -> b) -> List<a> -> List<b> =
  let rec go = \f. \xs. match xs {
    List::Nil() -> List::Nil(),
    List::Cons(h, t) -> List::Cons(f h, go f t),
  } in
  go;